<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Tå­—è·¯å£ï½œç§‘æŠ€äº¤è­¦ç‰ˆï¼ˆå–æ¶ˆæ—©æ™šï¼‰ï¼‹ä¸»2å³è»Šé“=ç•«é¢å³é‚Šï¼‹è»Šæµç™¾åˆ†æ¯”å¯èª¿</title>
  <style>
    :root{
      --bg:#0b1220;
      --panel:#121a2b;
      --text:#e8eefc;
      --muted:#a9b6d6;
      --good:#3cff7a;
      --bad:#ff3b3b;
      --warn:#ffd43b;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans TC", Arial;
      background: radial-gradient(1200px 800px at 30% 20%, #18234a 0%, var(--bg) 55%, #060a14 100%);
      color:var(--text);
      min-height:100vh;
      display:flex;
    }
    .wrap{
      width:min(1320px, 100%);
      margin:0 auto;
      padding:18px;
      display:grid;
      grid-template-columns: 1fr 460px;
      gap:16px;
      align-items:start;
    }
    .card{
      background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 16px;
      box-shadow: 0 18px 60px rgba(0,0,0,0.35);
      overflow:hidden;
    }
    .canvasWrap{ padding:12px; }
    canvas{
      width:100%;
      height:680px;
      display:block;
      background: rgba(0,0,0,0.18);
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.08);
    }
    .panel{ padding:14px; background: rgba(0,0,0,0.12); }
    h1{ font-size:15px; margin:0 0 10px 0; letter-spacing:.4px; line-height:1.35;}
    .pill{
      display:inline-flex;
      gap:8px;
      align-items:center;
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.18);
      font-size: 12px;
      color: var(--muted);
      margin-bottom:8px;
    }
    .dot{width:10px;height:10px;border-radius:50%;}
    .dot.green{background:var(--good)}
    .dot.red{background:var(--bad)}
    .dot.yellow{background:var(--warn)}
    .divider{ height:1px; background: rgba(255,255,255,0.10); margin: 12px 0; }
    .row{ display:flex; gap:10px; align-items:center; justify-content:space-between; margin:10px 0; }
    label{ font-size: 13px; color: var(--muted); }
    input[type="number"]{
      width: 190px;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(0,0,0,0.22);
      color: var(--text);
      outline:none;
    }
    .btns{ display:flex; gap:10px; margin-top:12px; }
    button{
      flex:1;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.14);
      background: linear-gradient(180deg, rgba(255,255,255,0.10), rgba(255,255,255,0.03));
      color: var(--text);
      cursor:pointer;
      font-weight: 600;
    }
    button:hover{filter:brightness(1.08)}
    button:disabled{opacity:.55; cursor:not-allowed; filter:none}
    .kv{
      display:grid;
      grid-template-columns: 1fr auto;
      gap:10px;
      align-items:center;
      margin: 8px 0;
      font-size: 13px;
    }
    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace; }
    .tiny{ font-size: 11px; color: var(--muted); line-height: 1.5; }
    .subcard{
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 12px;
      padding: 10px;
      background: rgba(0,0,0,0.16);
      margin-top: 10px;
      transition: opacity .15s ease, filter .15s ease;
    }
    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
      margin-top: 8px;
    }
    .checkrow{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin: 6px 0;
    }
    input[type="checkbox"]{ transform: scale(1.1); }
    .note{
      font-size:12px;
      color: var(--muted);
      line-height:1.55;
      margin-top:10px;
    }
    code{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      font-size: 12px;
      color: #d6e1ff;
      background: rgba(0,0,0,0.22);
      padding: 2px 6px;
      border-radius: 6px;
      border: 1px solid rgba(255,255,255,0.10);
    }

    .modeBtns{ display:flex; gap:10px; margin-top: 6px; }
    .modeBtn{
      flex:1;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(0,0,0,0.18);
      color: var(--text);
      cursor:pointer;
      font-weight: 800;
      letter-spacing: .6px;
    }
    .modeBtn.active{
      border-color: rgba(60,255,140,0.65);
      box-shadow: 0 0 0 2px rgba(60,255,140,0.20) inset;
      background: linear-gradient(180deg, rgba(60,255,140,0.18), rgba(0,0,0,0.10));
    }
    .subcard.disabled{
      opacity: .45;
      filter: grayscale(1);
      pointer-events: none;
    }

    select{
      width:190px;
      padding:8px 10px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,0.14);
      background: rgba(0,0,0,0.22);
      color: var(--text);
      outline:none;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card canvasWrap">
      <canvas id="c"></canvas>
    </div>

    <div class="card panel">
      <h1>
        âœ… ç§‘æŠ€äº¤è­¦ç‰ˆï¼ˆå·²å–æ¶ˆæ—©æ™šé¸é …ï¼‰<br/>
        âœ… ä¸»2 å…©è»Šé“ï¼š<b>ç•«é¢å³é‚Šè»Šé“ï¼å³è½‰</b>ã€ç•«é¢å·¦é‚Šè»Šé“ï¼å·¦è½‰<br/>
        âœ… M1T å¾ŒåŠæ®µå¯é‡ç–Šæ”¾ M2 å³è½‰ï¼ˆæœ‰è¡çªå€å ç”¨ä¿è­·ï¼‰<br/>
        âœ… Spillback å›å µåµæ¸¬ï¼šå¿«å¡çˆ†å°±æ’å…¥æ•‘æ´ç›¸ä½ï¼‹å‹•æ…‹æ‹‰é•· max green
      </h1>

      <div class="pill">
        <span class="dot green" id="phaseDot"></span>
        <span id="phaseText">Phaseï¼š--</span>
      </div>

      <!-- âœ… å³æ–‘é¦¬ç·š æœ‰/ç„¡ -->
      <div class="modeBtns" style="margin-top:10px;">
        <button class="modeBtn" id="btnRightXwalkOn">æœ‰å³æ–‘é¦¬ç·š</button>
        <button class="modeBtn" id="btnRightXwalkOff">ç„¡å³æ–‘é¦¬ç·š</button>
      </div>
      <div class="tiny" id="xwalkHint" style="margin-top:6px;">
        å³æ–‘é¦¬ç·šï¼šåˆ‡æ›å¾Œæœƒç«‹åˆ»å½±éŸ¿è¡Œäººåºåˆ—ï¼ˆå·¦â†’ã€”å³å¯é¸ã€•â†’ä¸‹ï¼‰ã€‚
      </div>

      <div class="divider"></div>

      <div class="row">
        <label>ä¸»ç·š1 ç›´è¡Œç¶ ï¼ˆM1_SGï¼‰</label>
        <input type="number" id="tM1SG" min="10" max="120" value="25" />
      </div>
      <div class="row">
        <label>ä¸»ç·š1 è½‰å½ç¶ ï¼ˆM1_TGï¼‰</label>
        <input type="number" id="tM1TG" min="6" max="90" value="20" />
      </div>
      <div class="row">
        <label>ä¸»ç·š1 é»ƒï¼ˆM1_Yï¼‰</label>
        <input type="number" id="tM1Y" min="2" max="10" value="3" />
      </div>

      <div class="row">
        <label>ä¸»ç·š2 åŸºç¤ç¶ ï¼ˆM2_Gï¼‰</label>
        <input type="number" id="tM2G" min="10" max="120" value="35" />
      </div>
      <div class="row">
        <label>ä¸»ç·š2 é»ƒï¼ˆM2_Yï¼‰</label>
        <input type="number" id="tM2Y" min="2" max="10" value="3" />
      </div>

      <div class="row">
        <label>å…¨ç´…ç·©è¡ï¼ˆARï¼‰</label>
        <input type="number" id="tAR" min="1" max="15" value="1" />
      </div>

      <div class="row">
        <label>è»Šæµç”Ÿæˆç‡ï¼ˆ0~1ï¼‰</label>
        <input type="number" id="spawn" min="0" max="1" step="0.05" value="0.20" />
      </div>

      <!-- âœ… è»Šæµç™¾åˆ†æ¯”ï¼ˆ4å€‹ç©ºï¼‰ï¼Œå‰©ä¸‹è‡ªå‹•è£œåˆ°ã€Œä¸»1å³ä¾†ç›´è¡Œã€ -->
      <div class="subcard">
        <div class="tiny">
          è¨­å®šå››å€‹æ¯”ä¾‹ï¼ˆ0~100ï¼‰ã€‚<br/>
          å‰©ä¸‹æ¯”ä¾‹æœƒè‡ªå‹•è£œåˆ°ï¼š<code>ä¸»1å³ä¾†ç›´è¡Œ</code>ï¼ˆé¿å…ç¸½å’Œä¸åˆ° 100% æ™‚äº‚è·‘ï¼‰ã€‚<br/>
          ä¸»2è»Šé“å·²å›ºå®šï¼š<code>ç•«é¢å³é‚Šè»Šé“ï¼å³è½‰ï¼ˆlaneIdx:1ï¼‰</code>ã€<code>ç•«é¢å·¦é‚Šè»Šé“ï¼å·¦è½‰ï¼ˆlaneIdx:0ï¼‰</code>
        </div>

        <div class="row"><label>å³é‚Šä¸»1å·¦è½‰(å¾€ä¸‹) (%)</label><input type="number" id="pct_M1R_L" min="0" max="100" value="30"></div>
        <div class="row"><label>å·¦é‚Šä¸»1ç›´è¡Œ (%)</label><input type="number" id="pct_M1L_S" min="0" max="100" value="10"></div>
        <div class="row"><label>ä¸»2å³è»Šé“å³è½‰ (%)</label><input type="number" id="pct_M2_R" min="0" max="100" value="30"></div>
        <div class="row"><label>ä¸»2å·¦è»Šé“å·¦è½‰ (%)</label><input type="number" id="pct_M2_L" min="0" max="100" value="10"></div>
        <div class="tiny" id="pctHint" style="margin-top:6px;">--</div>
      </div>

      <div class="subcard">
        <div class="tiny">
          è¡Œäººåºåˆ—ï¼šå·¦â†’ï¼ˆå³å¯é¸ï¼‰â†’ä¸‹ã€‚æ¯æ¢æœƒè·‘ <code>WALK</code> å†è·‘ <code>CLEAR</code>ã€‚<br/>
          WALK/CLEAR æœŸé–“ï¼šåªæ“‹ã€Œè¡çªæ–¹å‘è»Šæµã€ï¼Œå…¶ä»–è»Šæµç…§èµ°ï¼ˆé¿å…å…¨éœæ­¢ï¼‰ã€‚
        </div>

        <div class="grid2">
          <div class="subcard" style="margin:0;">
            <div class="checkrow">
              <label>å·¦æ–‘é¦¬ç·š</label><input type="checkbox" id="pLeftOn" checked />
            </div>
            <div class="row"><label>WALK</label><input type="number" id="pLeftWalk" min="3" max="60" value="10" /></div>
            <div class="row"><label>CLEAR</label><input type="number" id="pLeftClr" min="2" max="30" value="6" /></div>
          </div>

          <div class="subcard" id="rightPedCard" style="margin:0;">
            <div class="checkrow">
              <label>å³æ–‘é¦¬ç·š</label><input type="checkbox" id="pRightOn" checked />
            </div>
            <div class="row"><label>WALK</label><input type="number" id="pRightWalk" min="3" max="60" value="10" /></div>
            <div class="row"><label>CLEAR</label><input type="number" id="pRightClr" min="2" max="30" value="6" /></div>
          </div>

          <div class="subcard" style="margin:0; grid-column:1 / span 2;">
            <div class="checkrow">
              <label>ä¸‹æ–¹æ–‘é¦¬ç·š</label><input type="checkbox" id="pBottomOn" checked />
            </div>
            <div class="row"><label>WALK</label><input type="number" id="pBottomWalk" min="3" max="60" value="20" /></div>
            <div class="row"><label>CLEAR</label><input type="number" id="pBottomClr" min="2" max="30" value="8" /></div>
          </div>
        </div>

        <div class="note">
          âœ… ç§‘æŠ€äº¤è­¦æ•‘æ´ï¼šå›å µæ¥è¿‘ç•«é¢é‚Šç•Œå°±æ’å…¥æ•‘æ´ç›¸ä½ã€å»¶é•· max green æ¸…éšŠï¼Œé¿å…ã€Œæ•´å€‹è·¯å£é–æ­»ã€ã€‚<br/>
          âœ… M1T å¾ŒåŠæ®µå¯é‡ç–Šæ”¾ M2 å³è½‰ï¼šä½†è‹¥è¡çªå€æœ‰è½‰ä¸‹è»Šå ç”¨ï¼Œå°±æš«åœé‡ç–Šï¼ˆå®‰å…¨ä¿è­·ï¼‰ã€‚
        </div>
      </div>



      <!-- ===== ğŸ”Š è‡ªå‹•èªéŸ³æé†’ï¼ˆå›å µè§¸ç™¼ï¼‰ ===== -->
      <div class="subcard" id="voiceCard">
        <div class="tiny"><b>ğŸ”Š è‡ªå‹•èªéŸ³æé†’ï¼ˆå›å µè§¸ç™¼ï¼‰</b></div>

        <div class="checkrow">
          <label>å•Ÿç”¨èªéŸ³</label><input type="checkbox" id="voiceOn" checked />
        </div>

        <div class="row"><label>è§¸ç™¼é–€æª»ï¼ˆpxï¼‰</label><input type="number" id="voicePx" min="10" max="600" value="120" /></div>
        <div class="row"><label>å†·å»ç§’æ•¸</label><input type="number" id="voiceCd" min="2" max="300" value="12" /></div>

        <div class="tiny" style="margin-top:6px;">æ–¹å‘åˆ¥èªéŸ³ï¼šä¾å›å µä¾†æº <code>M1S/M1T/M2L/M2R</code> è‡ªå‹•æ’­ä¸åŒå…§å®¹ã€‚</div>

        <div class="btns" style="margin-top:10px;">
          <button id="voiceTest">æ¸¬è©¦æ’­å ±</button>
          <button id="voiceStop">åœæ­¢</button>
        </div>

        <div class="btns" style="margin-top:10px;">
          <button id="logDump">Logï¼šConsole è¡¨æ ¼</button>
          <button id="logExport">Logï¼šåŒ¯å‡º JSON</button>
        </div>
      </div>

      <!-- ===== ğŸ§© JSON å¡è»ŠåŠ‡æœ¬ ===== -->
      <div class="subcard" id="scenarioCard">
        <div class="tiny"><b>ğŸ§© JSON å¡è»ŠåŠ‡æœ¬</b></div>
        <div class="tiny">æ¯ç§’æª¢æŸ¥ <code>simSec</code>ï¼Œåˆ°æŒ‡å®šç§’æ•¸å°±å¥—ç”¨åƒæ•¸ï¼ˆspawn/è»Šæµæ¯”ä¾‹/ç¶ ç‡ˆç§’æ•¸ï¼‰ã€‚</div>

        <textarea id="scenarioJson" style="width:100%;height:160px;margin-top:8px;" placeholder='{
  "name": "å°–å³°æ¸¬è©¦",
  "events": [
    { "at": 0,   "set": { "spawn": 0.20 } },
    { "at": 60,  "set": { "spawn": 0.55, "pct_M2_R": 45 } },
    { "at": 120, "set": { "spawn": 0.70 } },
    { "at": 180, "set": { "spawn": 0.40 } }
  ]
}'></textarea>

        <div class="btns" style="margin-top:10px;">
          <button id="loadScenario">è¼‰å…¥åŠ‡æœ¬</button>
          <button id="clearScenario">æ¸…ç©º</button>
        </div>

        <div class="tiny" id="scenarioHint" style="margin-top:6px;">å°šæœªè¼‰å…¥</div>
      </div>

      <div class="btns">
        <button id="toggle">æš«åœ</button>
        <button id="reset">é‡ç½®</button>
      </div>

      <div class="divider"></div>

      <div class="kv"><div>ä¸»ç·š1 è»Šç‡ˆ</div><div class="mono" id="sigM1">--</div></div>
      <div class="kv"><div>ä¸»ç·š2 å·¦è½‰ç‡ˆ</div><div class="mono" id="sigM2L">--</div></div>
      <div class="kv"><div>ä¸»ç·š2 å³è½‰ç‡ˆ</div><div class="mono" id="sigM2R">--</div></div>
      <div class="kv"><div>è¡Œäººç‹€æ…‹</div><div class="mono" id="sigPed">--</div></div>
      <div class="kv"><div>æœ¬ç›¸ä½å‰©é¤˜ç§’</div><div class="mono" id="count">--</div></div>
      <div class="kv"><div>æ’éšŠ(ä¼°)</div><div class="mono" id="qText">--</div></div>
      <div class="kv"><div>ç§‘æŠ€äº¤è­¦</div><div class="mono" id="copText">--</div></div>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  const $ = (id) => document.getElementById(id);

  const ui = {
    tM1SG: $('tM1SG'),
    tM1TG: $('tM1TG'),
    tM1Y: $('tM1Y'),
    tM2G: $('tM2G'), tM2Y: $('tM2Y'),
    tAR: $('tAR'),
    spawn: $('spawn'),


    // ğŸ”Š voice
    voiceOn: $('voiceOn'),
    voicePx: $('voicePx'),
    voiceCd: $('voiceCd'),
    voiceTest: $('voiceTest'),
    voiceStop: $('voiceStop'),

    // ğŸ§© scenario
    scenarioJson: $('scenarioJson'),
    loadScenario: $('loadScenario'),
    clearScenario: $('clearScenario'),
    scenarioHint: $('scenarioHint'),

    // ğŸ“Š log
    logDump: $('logDump'),
    logExport: $('logExport'),

    // è»Šæµç™¾åˆ†æ¯”ï¼ˆå››é …ï¼‰
    pct_M1R_L: $('pct_M1R_L'),
    pct_M1L_S: $('pct_M1L_S'),
    pct_M2_R:  $('pct_M2_R'),
    pct_M2_L:  $('pct_M2_L'),
    pctHint:   $('pctHint'),

    pLeftOn: $('pLeftOn'), pRightOn: $('pRightOn'), pBottomOn: $('pBottomOn'),
    pLeftWalk: $('pLeftWalk'), pLeftClr: $('pLeftClr'),
    pRightWalk: $('pRightWalk'), pRightClr: $('pRightClr'),
    pBottomWalk: $('pBottomWalk'), pBottomClr: $('pBottomClr'),
    rightPedCard: $('rightPedCard'),

    btnRightXwalkOn: $('btnRightXwalkOn'),
    btnRightXwalkOff: $('btnRightXwalkOff'),
    xwalkHint: $('xwalkHint'),

    toggle: $('toggle'), reset: $('reset'),

    phaseDot: $('phaseDot'), phaseText: $('phaseText'),
    sigM1: $('sigM1'),
    sigM2L: $('sigM2L'),
    sigM2R: $('sigM2R'),
    sigPed: $('sigPed'),
    count: $('count'),
    qText: $('qText'),
    copText: $('copText'),
  };

  const SIG = { RED:'RED', YELLOW:'YELLOW', GREEN:'GREEN' };


  // =======================
  // ğŸ“Š Log ç³»çµ±ï¼ˆå›å µ/æ’­éŸ³ï¼‰
  // =======================
  const TRAFFIC_LOG = [];
  function logEvent(obj){
    TRAFFIC_LOG.push({ time: simSec, ...obj });
  }
  function dumpTrafficLog(){
    console.table(TRAFFIC_LOG);
    return TRAFFIC_LOG;
  }
  function exportTrafficLog(){
    const blob = new Blob([JSON.stringify(TRAFFIC_LOG, null, 2)], {type:'application/json'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = `traffic_log_${Date.now()}.json`;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(()=>URL.revokeObjectURL(a.href), 1000);
  }

  // =======================
  // ğŸ”Š æ–¹å‘åˆ¥èªéŸ³å…§å®¹
  // =======================
  const VOICE_BY_DIR = {
    M1S: 'ä¸»ç·šç›´è¡Œè»Šæµå›å µï¼Œè«‹ä¾è™ŸèªŒè¡Œé§›ï¼Œå‹¿ä½”ç”¨è·¯å£ï¼Œå·²å•Ÿç”¨ç§‘æŠ€åŸ·æ³•ã€‚',
    M1T: 'ä¸»ç·šè½‰å‘è»Šæµå›å µï¼Œè«‹å‹¿æ¶å¿«é€šè¡Œï¼Œç´…ç‡ˆè«‹åœï¼Œç§‘æŠ€åŸ·æ³•ä¸­ã€‚',
    M2L: 'ä¸‹æ¸¸å·¦è½‰è»Šé“å·²å›å µï¼Œè«‹ä¾è™ŸèªŒè¡Œé§›ï¼Œå‹¿é—–ç´…ç‡ˆã€‚',
    M2R: 'ä¸‹æ¸¸å³è½‰è»Šé“è»Šæµå£…å¡ï¼Œè«‹ä¾åºé€šè¡Œï¼Œè·¯å£å·²å•Ÿç”¨ç§‘æŠ€åŸ·æ³•ã€‚',
    GEN: 'å‰æ–¹è·¯å£è»Šæµå£…å¡ï¼Œè«‹éµå®ˆè™ŸèªŒï¼Œç´…ç‡ˆè«‹åœï¼Œç§‘æŠ€åŸ·æ³•ä¸­ã€‚'
  };

  let voiceCooldownUntil = 0;
  let alertUntil = 0;

  function speak(text){
    if (!('speechSynthesis' in window)) return;
    window.speechSynthesis.cancel();
    const u = new SpeechSynthesisUtterance(text);
    u.lang = 'zh-TW';
    u.rate = 0.95;
    u.pitch = 1.0;
    u.volume = 1.0;
    window.speechSynthesis.speak(u);
  }
  function stopSpeak(){
    if (!('speechSynthesis' in window)) return;
    window.speechSynthesis.cancel();
  }

  function startVisualAlert(durationSec = 2.5){
    alertUntil = performance.now() + durationSec * 1000;
  }
  function drawAlertOverlay(g){
    if (performance.now() > alertUntil) return;
    const t = performance.now();
    const alpha = 0.35 + 0.25 * Math.sin(t / 120);
    ctx.save();
    ctx.strokeStyle = `rgba(255,0,0,${alpha})`;
    ctx.lineWidth = 8;
    ctx.strokeRect(6, 6, g.W - 12, g.H - 12);
    ctx.restore();
  }

  function voiceMaybeTrigger(spWorst){
    if (!ui.voiceOn?.checked) return;
    if (!spWorst) return;

    const pxTh = Number(ui.voicePx?.value ?? 120);
    const cd   = Number(ui.voiceCd?.value ?? 12);
    if (simSec < voiceCooldownUntil) return;

    if (spWorst.severityPx < pxTh){
      const dir = spWorst.key || 'GEN';
      const msg = VOICE_BY_DIR[dir] || VOICE_BY_DIR.GEN;
      speak(msg);
      voiceCooldownUntil = simSec + Math.max(2, cd);
      startVisualAlert();
      logEvent({ type:'VOICE', dir, severityPx: spWorst.severityPx, message: msg });
    }
  }

  // =======================
  // ğŸ§© JSON å¡è»ŠåŠ‡æœ¬ï¼ˆå¯æ”¹åƒæ•¸ï¼‰
  // =======================
  const APPLY_MAP = {
    spawn: 'spawn',
    pct_M1R_L: 'pct_M1R_L',
    pct_M1L_S: 'pct_M1L_S',
    pct_M2_R:  'pct_M2_R',
    pct_M2_L:  'pct_M2_L',
    tM1SG: 'tM1SG',
    tM1TG: 'tM1TG',
    tM1Y:  'tM1Y',
    tM2G:  'tM2G',
    tM2Y:  'tM2Y',
    tAR:   'tAR',
    pLeftWalk: 'pLeftWalk', pLeftClr: 'pLeftClr',
    pRightWalk:'pRightWalk',pRightClr:'pRightClr',
    pBottomWalk:'pBottomWalk',pBottomClr:'pBottomClr'
  };

  let scenario = null;
  let scenarioIdx = 0;

  function applyScenarioSet(setObj){
    if (!setObj) return;
    for (const [k,v] of Object.entries(setObj)){
      const uiKey = APPLY_MAP[k];
      if (!uiKey || !ui[uiKey]) continue;
      ui[uiKey].value = String(v);
    }
    // å¥—å®Œç«‹å³åˆ·æ–°ï¼ˆæ¯”ä¾‹/ç›¸ä½/è¡Œäººï¼‰
    if (typeof readFlowPcts === 'function') readFlowPcts();
    if (typeof softApply === 'function') softApply();
  }

  function loadScenarioFromText(txt){
    let obj;
    try{ obj = JSON.parse(txt); }
    catch(e){ ui.scenarioHint.textContent = 'âŒ JSON è§£æå¤±æ•—'; return; }
    if (!obj || !Array.isArray(obj.events)){
      ui.scenarioHint.textContent = 'âŒ éœ€è¦ {"events": [...]}';
      return;
    }
    obj.events = obj.events
      .map(e => ({ at: Number(e.at||0), set: e.set||{} }))
      .sort((a,b)=>a.at-b.at);
    scenario = obj;
    scenarioIdx = 0;
    ui.scenarioHint.textContent = `âœ… å·²è¼‰å…¥ï¼š${obj.name||'æœªå‘½å'}ï½œäº‹ä»¶æ•¸ ${obj.events.length}`;
  }

  function scenarioTick(){
    if (!scenario || !scenario.events?.length) return;
    while (scenarioIdx < scenario.events.length && simSec >= scenario.events[scenarioIdx].at){
      applyScenarioSet(scenario.events[scenarioIdx].set);
      scenarioIdx += 1;
    }
  }

  function clampInt(v,min,max){
    const n = Math.round(Number(v)||0);
    return Math.max(min, Math.min(max, n));
  }

  function getDur(){
    return {
      M1SG: clampInt(ui.tM1SG.value, 10, 120),
      M1TG: clampInt(ui.tM1TG.value, 6, 90),
      M1Y:  clampInt(ui.tM1Y.value,  2, 10),
      M2G:  clampInt(ui.tM2G.value,  10, 120),
      M2Y:  clampInt(ui.tM2Y.value,  2, 10),
      AR:   clampInt(ui.tAR.value,   1, 15),
    };
  }

  function resizeCanvasToCSS(){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const rect = canvas.getBoundingClientRect();
    const w = Math.max(1, Math.round(rect.width * dpr));
    const h = Math.max(1, Math.round(rect.height * dpr));
    if (canvas.width !== w || canvas.height !== h){
      canvas.width = w; canvas.height = h;
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
  }

  function geom(){
    const rect = canvas.getBoundingClientRect();
    const W = rect.width, H = rect.height;

    const road = {
      y: Math.round(H*0.38),
      h: 150,
      x: Math.round(W*0.52),
      w: 240,
    };
    const inter = {
      x0: road.x-road.w/2,
      x1: road.x+road.w/2,
      y0: road.y-road.h/2,
      y1: road.y+road.h/2,
    };

    const lane = {
      m1_east_y: road.y + 22,
      m1_west_y: road.y - 22,
      stem_out_x: [road.x - 48, road.x - 20],
      stem_in_x:  [road.x + 20, road.x + 48], // 0=ç•«é¢å·¦è»Šé“, 1=ç•«é¢å³è»Šé“
    };

    const stop = {
      m1_left: inter.x0 - 22,
      m1_right: inter.x1 + 22,
      m2_in: inter.y1 + 22,
    };

    const xwalk = {
      left:   { x: inter.x0 - 55, y: road.y-road.h/2 + 8, w: 42, h: road.h-16 },
      right:  { x: inter.x1 + 13, y: road.y-road.h/2 + 8, w: 42, h: road.h-16 },
      bottom: { x: road.x-road.w/2 + 8, y: inter.y1 + 14, w: road.w-16, h: 42 },
    };

    return { W,H,road,inter,lane,stop,xwalk };
  }

  // ===== å³æ–‘é¦¬ç·šåˆ‡æ› =====
  let rightXwalkEnabled = true;
  function setRightXwalk(enabled){
    rightXwalkEnabled = !!enabled;

    ui.pRightOn.checked = rightXwalkEnabled;

    ui.btnRightXwalkOn?.classList.toggle('active', rightXwalkEnabled);
    ui.btnRightXwalkOff?.classList.toggle('active', !rightXwalkEnabled);

    ui.rightPedCard?.classList.toggle('disabled', !rightXwalkEnabled);

    softApply();

    ui.xwalkHint.textContent = rightXwalkEnabled
      ? 'å³æ–‘é¦¬ç·šï¼šç›®å‰ã€Œæœ‰ã€â€” è¡Œäººåºåˆ—ï¼šå·¦â†’å³â†’ä¸‹'
      : 'å³æ–‘é¦¬ç·šï¼šç›®å‰ã€Œç„¡ã€â€” è¡Œäººåºåˆ—ï¼šå·¦â†’ä¸‹ï¼ˆè·³éå³ï¼‰';
  }

  // ===== è¡Œäººåºåˆ— =====
  let pedSteps = [];
  let pedIndex = 0;

  function buildPedSteps(){
    const steps = [];
    const add = (name, on, walkEl, clrEl) => {
      if (!on) return;
      const w = clampInt(walkEl.value, 3, 60);
      const c = clampInt(clrEl.value, 2, 30);
      steps.push({ key:`${name}_WALK`, dur:w });
      steps.push({ key:`${name}_CLEAR`, dur:c });
    };
    add('LEFT', ui.pLeftOn.checked, ui.pLeftWalk, ui.pLeftClr);
    if (rightXwalkEnabled) add('RIGHT', ui.pRightOn.checked, ui.pRightWalk, ui.pRightClr);
    add('BOTTOM', ui.pBottomOn.checked, ui.pBottomWalk, ui.pBottomClr);
    if (steps.length === 0) steps.push({ key:'NONE_CLEAR', dur: 2 });
    return steps;
  }

  // ===== è»Šæµç™¾åˆ†æ¯”ï¼ˆå››é … + è‡ªå‹•è£œå‰©é¤˜ï¼‰=====
  function readFlowPcts(){
    const p1 = Number(ui.pct_M1R_L.value)||0; // å³é‚Šä¸»1å·¦è½‰(å¾€ä¸‹)
    const p2 = Number(ui.pct_M1L_S.value)||0; // å·¦é‚Šä¸»1ç›´è¡Œ
    const p3 = Number(ui.pct_M2_R.value)||0;  // ä¸»2å³è»Šé“å³è½‰ï¼ˆç•«é¢å³é‚Šè»Šé“ï¼‰
    const p4 = Number(ui.pct_M2_L.value)||0;  // ä¸»2å·¦è»Šé“å·¦è½‰ï¼ˆç•«é¢å·¦é‚Šè»Šé“ï¼‰

    const sum4 = p1+p2+p3+p4;
    const rest = 100 - sum4; // è‡ªå‹•è£œåˆ° ä¸»1å³ä¾†ç›´è¡Œ

    if (ui.pctHint){
      ui.pctHint.textContent =
        sum4 > 100
          ? `âš ï¸ å››é …ç¸½å’Œ ${sum4}%ï¼ˆè¶…é100ï¼Œè«‹èª¿å°ï¼‰`
          : `å››é …ç¸½å’Œ ${sum4}%ï½œå‰©é¤˜ ${rest}% â†’ è‡ªå‹•è£œåˆ°ã€Œä¸»1å³ä¾†ç›´è¡Œã€`;
    }
    return { p1,p2,p3,p4,sum4,rest };
  }

  // ===== æ§åˆ¶å™¨ï¼ˆç§‘æŠ€äº¤è­¦åƒæ•¸ï¼‰ =====
  const CTRL = {
    EXTEND_IF_Q_GE: 2,
    EXTEND_STEP: 1,

    M1S_MIN: 10, M1S_MAX: 50,
    M1T_MIN: 10, M1T_MAX: 65,
    M2L_MIN: 10, M2L_MAX: 80,
    M2R_MIN: 8,  M2R_MAX: 55,

    SKIP_IF_Q_LE: 0,

    STARVE_SEC: 60,
    STARVE_BONUS: 6,

    PED_ALWAYS: true,
    PED_MAX_DELAY: 120,
    PED_SUPPRESS_IF_PRESSURE_GE: 16,

    // M1T å¾ŒåŠæ®µé‡ç–Šæ”¾ M2R
    OVERLAP_M2R_WITH_M1T: true,
    OVERLAP_M2R_MIN_Q: 2,
    OVERLAP_M1T_START_RATIO: 0.55,
    OVERLAP_CONFLICT_PAD: 18,

    // ç§‘æŠ€äº¤è­¦ï¼šSpillback
    COP_ENABLED: true,
    SPILLBACK_MARGIN_PX: 120,
    COP_FORCE_INSERT: true,
    COP_MIN_GREEN: 14,
    COP_MAX_GREEN_BOOST: 25,
    COP_COOLDOWN_SEC: 8,
  };

  // ===== ç›¸ä½ =====
  const PH = {
    M1S_G:'M1S_G',
    M1T_G:'M1T_G',
    M2L_G:'M2L_G', // ä¸»2å·¦è½‰
    M2R_G:'M2R_G', // ä¸»2å³è½‰
    PSEQ:'PSEQ',

    M1_Y:'M1_Y',
    M2L_Y:'M2L_Y',
    M2R_Y:'M2R_Y',

    AR:'AR',
  };

  let phase = PH.M1S_G;
  let remaining = 0;
  let phaseElapsed = 0;

  const lastServedAt = { M1S:0, M1T:0, M2L:0, M2R:0, PED:0 };
  let simSec = 0;

  let cop = {
    active: false,
    targetKey: null,
    cooldownUntil: 0,
    reason: '',
    boostedMax: null,
  };

  function activePedStep(){
    if (phase !== PH.PSEQ) return null;
    return pedSteps[pedIndex] || { key:'NONE_CLEAR', dur: 0 };
  }

  // ===== è»Š =====
  const cars = [];
  const CAR_W = 22, CAR_H = 14;

  function rnd(a,b){ return a + Math.random()*(b-a); }

  function stopLine(car, g){
    if (car.kind === 'M1L') return g.stop.m1_left;
    if (car.kind === 'M1R') return g.stop.m1_right;
    return g.stop.m2_in;
  }

  function pastStop(car, g){
    const s = stopLine(car, g);
    if (car.kind === 'M1L') return car.x > s;
    if (car.kind === 'M1R') return car.x < s;
    return car.y < s;
  }

  function approachingStop(car, g){
    const s = stopLine(car, g);
    if (car.kind === 'M1L') return car.x + car.w/2 >= s - 2;
    if (car.kind === 'M1R') return car.x - car.w/2 <= s + 2;
    return car.y - car.h/2 <= s + 2;
  }

  function pedAllowsCar(car, sig){
    if (phase !== PH.PSEQ) return true;
    const which = sig.pedWhich;
    const mode  = sig.pedMode;
    if (mode === 'NONE') return true;

    if (which === 'LEFT'   && car.kind === 'M1L') return false;
    if (which === 'RIGHT'  && car.kind === 'M1R') return false;
    if (which === 'BOTTOM' && car.kind === 'M2')  return false;

    return true;
  }

  // ===== è¡çªå€ï¼ˆé‡ç–Šä¿è­·ï¼‰ =====
  function rectOverlap(ax,ay,aw,ah, bx,by,bw,bh){
    return !(ax+aw < bx || bx+bw < ax || ay+ah < by || by+bh < ay);
  }

  function conflictZone(g){
    const pad = CTRL.OVERLAP_CONFLICT_PAD;
    const x = g.road.x - 70 - pad;
    const y = g.road.y - 40 - pad;
    const w = 140 + pad*2;
    const h = 120 + pad*2;
    return { x,y,w,h };
  }

  function conflictOccupiedByDownTurners(g){
    const z = conflictZone(g);
    for (const c of cars){
      const isDownTurn = (c.route === 'down') && (c.kind === 'M1L' || c.kind === 'M1R');
      if (!isDownTurn) continue;

      const bx = c.x - c.w/2;
      const by = c.y - c.h/2;
      if (rectOverlap(z.x,z.y,z.w,z.h, bx,by,c.w,c.h)) return true;
    }
    return false;
  }

  // ===== æ’éšŠé‡æ¸¬ =====
  function measureQueues(g){
    let m1TurnQ = 0, m1StraightQ = 0;
    let m2Q = 0, m2LQ = 0, m2RQ = 0;

    for (const c of cars){
      if (pastStop(c, g)) continue;

      if (c.kind === 'M1L' || c.kind === 'M1R'){
        const s = stopLine(c, g);
        const dist = (c.kind === 'M1L') ? (s - c.x) : (c.x - s);
        if (dist < -30) continue;
        if (dist > 260) continue;

        if (c.route === 'down') m1TurnQ++;
        else m1StraightQ++;
      }

      if (c.kind === 'M2'){
        const s = stopLine(c, g);
        const dist = (c.y - s);
        if (dist < -30) continue;
        if (dist > 260) continue;

        m2Q++;
        if (c.route === 'toLeft') m2LQ++;
        else if (c.route === 'toRight') m2RQ++;
      }
    }
    return { m1TurnQ, m1StraightQ, m2Q, m2LQ, m2RQ };
  }

  // ===== ç§‘æŠ€äº¤è­¦ï¼šSpillback åµæ¸¬ =====
  function spillbackStatus(g){
    const margin = CTRL.SPILLBACK_MARGIN_PX;

    let tail_M1L = null;
    let tail_M1R = null;
    let tail_M2  = [null, null]; // laneIdx 0/1

    for (const c of cars){
      if (pastStop(c, g)) continue;

      if (c.kind === 'M1L'){
        if (!tail_M1L || c.x < tail_M1L.x) tail_M1L = c;
      } else if (c.kind === 'M1R'){
        if (!tail_M1R || c.x > tail_M1R.x) tail_M1R = c;
      } else if (c.kind === 'M2'){
        const i = c.laneIdx ?? 0;
        if (!tail_M2[i] || c.y > tail_M2[i].y) tail_M2[i] = c;
      }
    }

    const status = { worst:null };

    const consider = (key, distToEdgePx, reason) => {
      if (distToEdgePx >= margin) return;
      const severity = distToEdgePx; // è¶Šå°è¶Šåš´é‡
      if (!status.worst || severity < status.worst.severityPx){
        status.worst = { key, severityPx: severity, reason };
      }
    };

    if (tail_M1L) consider('M1S', tail_M1L.x, 'ä¸»1å·¦å…¥å£å›å µï¼ˆç›´è¡Œï¼‰');
    if (tail_M1R) consider('M1T', (g.W - tail_M1R.x), 'ä¸»1å³å…¥å£å›å µï¼ˆå·¦è½‰å¾€ä¸‹/ç›´è¡Œï¼‰');

    // âœ… æ³¨æ„ï¼šlaneIdx:0=ç•«é¢å·¦ï¼ŒlaneIdx:1=ç•«é¢å³
    if (tail_M2[0]) consider('M2L', (g.H - tail_M2[0].y), 'ä¸»2å·¦è»Šé“å›å µï¼ˆå·¦è½‰ï¼‰');
    if (tail_M2[1]) consider('M2R', (g.H - tail_M2[1].y), 'ä¸»2å³è»Šé“å›å µï¼ˆå³è½‰ï¼‰');

    return status;
  }

  function copDecide(g, q){
    if (!CTRL.COP_ENABLED) return null;
    if (simSec < cop.cooldownUntil) return null;

    const sp = spillbackStatus(g);
    if (!sp.worst) return null;

    const key = sp.worst.key;
    const demand =
      key === 'M1S' ? q.m1StraightQ :
      key === 'M1T' ? q.m1TurnQ :
      key === 'M2L' ? q.m2LQ :
      key === 'M2R' ? q.m2RQ : 0;

    if (demand <= 0) return null;

    return { key, reason: sp.worst.reason, severityPx: sp.worst.severityPx };
  }

  // ===== å£“åŠ›æ§åˆ¶æŒ‘ç›¸ä½ =====
  function pressureScore(key, q){
    let base =
      key === 'M1S' ? q.m1StraightQ :
      key === 'M1T' ? q.m1TurnQ :
      key === 'M2L' ? q.m2LQ :
      key === 'M2R' ? q.m2RQ : 0;

    const last = lastServedAt[key] || 0;
    const wait = Math.max(0, simSec - last);
    if (wait >= CTRL.STARVE_SEC) base += CTRL.STARVE_BONUS;

    return base;
  }

  function pickNextGreen(q){
    const cands = ['M1S','M1T','M2L','M2R'];
    const anyDemand = (q.m1StraightQ + q.m1TurnQ + q.m2LQ + q.m2RQ) > 0;
    if (!anyDemand) return 'M1S';

    let best = cands[0];
    let bestScore = -1e9;
    for (const k of cands){
      const s = pressureScore(k, q);
      if (s > bestScore){
        bestScore = s;
        best = k;
      }
    }
    return best;
  }

  function greenFromKey(k){
    if (k === 'M1S') return PH.M1S_G;
    if (k === 'M1T') return PH.M1T_G;
    if (k === 'M2L') return PH.M2L_G;
    if (k === 'M2R') return PH.M2R_G;
    return PH.M1S_G;
  }

  function minMaxForGreen(ph){
    const base = (()=>{
      switch(ph){
        case PH.M1S_G: return [CTRL.M1S_MIN, CTRL.M1S_MAX];
        case PH.M1T_G: return [CTRL.M1T_MIN, CTRL.M1T_MAX];
        case PH.M2L_G: return [CTRL.M2L_MIN, CTRL.M2L_MAX];
        case PH.M2R_G: return [CTRL.M2R_MIN, CTRL.M2R_MAX];
        default: return [10, 40];
      }
    })();

    if (cop.active && cop.boostedMax && (
      (ph === PH.M1S_G && cop.targetKey === 'M1S') ||
      (ph === PH.M1T_G && cop.targetKey === 'M1T') ||
      (ph === PH.M2L_G && cop.targetKey === 'M2L') ||
      (ph === PH.M2R_G && cop.targetKey === 'M2R')
    )){
      return [Math.max(base[0], CTRL.COP_MIN_GREEN), cop.boostedMax];
    }

    return base;
  }

  function demandForGreen(ph, q){
    switch(ph){
      case PH.M1S_G: return q.m1StraightQ;
      case PH.M1T_G: return q.m1TurnQ;
      case PH.M2L_G: return q.m2LQ;
      case PH.M2R_G: return q.m2RQ;
      default: return 0;
    }
  }

  function canOverlapM2RWithM1T(g, q){
    if (!CTRL.OVERLAP_M2R_WITH_M1T) return false;
    if (phase !== PH.M1T_G) return false;

    const d = getDur();
    const baseM1T = d.M1TG;
    const ratio = baseM1T <= 0 ? 1 : (phaseElapsed / baseM1T);
    if (ratio < CTRL.OVERLAP_M1T_START_RATIO) return false;

    if (q.m2RQ < CTRL.OVERLAP_M2R_MIN_Q) return false;
    if (conflictOccupiedByDownTurners(g)) return false;
    return true;
  }

  // ===== ä¿¡è™Ÿç‡ˆ =====
  function signals(){
    const all = {
      m1: SIG.RED,
      m2L: SIG.RED,
      m2R: SIG.RED,
      pedLeft: 'STOP',
      pedRight: 'STOP',
      pedBottom: 'STOP',
      pedMode: 'NONE',
      pedWhich: 'NONE',
    };

    if (phase === PH.PSEQ){
      const step = activePedStep();
      const s = { ...all };
      const isWalk = step.key.endsWith('_WALK');
      const isClear = step.key.endsWith('_CLEAR');

      if (step.key.startsWith('LEFT_')){
        s.pedLeft = isWalk ? 'WALK' : (isClear ? 'CLEAR' : 'STOP');
        s.pedWhich = 'LEFT';
      } else if (step.key.startsWith('RIGHT_')){
        s.pedRight = isWalk ? 'WALK' : (isClear ? 'CLEAR' : 'STOP');
        s.pedWhich = 'RIGHT';
      } else if (step.key.startsWith('BOTTOM_')){
        s.pedBottom = isWalk ? 'WALK' : (isClear ? 'CLEAR' : 'STOP');
        s.pedWhich = 'BOTTOM';
      }
      s.pedMode = isWalk ? 'WALK' : (isClear ? 'CLEAR' : 'NONE');
      return s;
    }

    if (phase === PH.M1S_G) return { ...all, m1: SIG.GREEN };

    if (phase === PH.M1T_G){
      const g = geom();
      const q = measureQueues(g);
      const overlap = canOverlapM2RWithM1T(g, q);
      return { ...all, m1: SIG.GREEN, m2R: overlap ? SIG.GREEN : SIG.RED, m2L: SIG.RED };
    }

    if (phase === PH.M1_Y) return { ...all, m1: SIG.YELLOW };

    if (phase === PH.M2L_G) return { ...all, m2L: SIG.GREEN };
    if (phase === PH.M2R_G) return { ...all, m2R: SIG.GREEN };

    if (phase === PH.M2L_Y) return { ...all, m2L: SIG.YELLOW };
    if (phase === PH.M2R_Y) return { ...all, m2R: SIG.YELLOW };

    return all;
  }

  function allowedBySignal(car, sig, g){
    if (phase === PH.PSEQ) return pedAllowsCar(car, sig);

    if (car.kind === 'M1L' || car.kind === 'M1R'){
      if (sig.m1 === SIG.YELLOW) return pastStop(car, g);
      if (sig.m1 !== SIG.GREEN) return false;

      if (phase === PH.M1S_G){
        if (pastStop(car, g)) return true;
        return car.route === 'straight';
      }
      if (phase === PH.M1T_G){
        if (pastStop(car, g)) return true;
        return (car.route === 'down' || car.route === 'straight');
      }
      return false;
    }

    if (car.kind === 'M2'){
      if (sig.m2L === SIG.GREEN) return (car.route === 'toLeft')  || pastStop(car, g);
      if (sig.m2R === SIG.GREEN) return (car.route === 'toRight') || pastStop(car, g);
      if (sig.m2L === SIG.YELLOW || sig.m2R === SIG.YELLOW) return pastStop(car, g);
      return false;
    }

    return false;
  }

  // ===== ç”Ÿæˆè»Šï¼šä¾å››é …ç™¾åˆ†æ¯”ï¼ˆä¸»2å³è»Šé“=ç•«é¢å³é‚Š laneIdx:1ï¼‰=====
  function spawnCar(g){
    const p = Number(ui.spawn.value);
    if (Math.random() > p) return;

    const sp = rnd(95, 145);
    const { p1,p2,p3,p4,sum4 } = readFlowPcts();
    if (sum4 > 100) return;

    const A = p1 / 100;
    const B = (p1 + p2) / 100;
    const C = (p1 + p2 + p3) / 100;
    const D = (p1 + p2 + p3 + p4) / 100;
    const r = Math.random();

    // Aï¼šå³é‚Šä¸»1å·¦è½‰(å¾€ä¸‹)
    if (r < A){
      cars.push({ kind:'M1R', route:'down', x:g.W+80, y:g.lane.m1_west_y, vx:-sp, vy:0, w:CAR_W, h:CAR_H, turned:false });
      return;
    }

    // Bï¼šå·¦é‚Šä¸»1ç›´è¡Œ
    if (r < B){
      cars.push({ kind:'M1L', route:'straight', x:-80, y:g.lane.m1_east_y, vx:sp, vy:0, w:CAR_W, h:CAR_H, turned:false });
      return;
    }

    // Cï¼šä¸»2å³è»Šé“å³è½‰ï¼ˆç•«é¢å³é‚Š laneIdx:1ï¼‰
    if (r < C){
      cars.push({
        kind:'M2', laneIdx:1, route:'toRight',
        x:g.lane.stem_in_x[1], y:g.H+90,
        vx:0, vy:-sp, w:CAR_H, h:CAR_W, turned:false
      });
      return;
    }

    // Dï¼šä¸»2å·¦è»Šé“å·¦è½‰ï¼ˆç•«é¢å·¦é‚Š laneIdx:0ï¼‰
    if (r < D){
      cars.push({
        kind:'M2', laneIdx:0, route:'toLeft',
        x:g.lane.stem_in_x[0], y:g.H+90,
        vx:0, vy:-sp, w:CAR_H, h:CAR_W, turned:false
      });
      return;
    }

    // Eï¼šå‰©ä¸‹å…¨éƒ¨ â†’ ä¸»1å³ä¾†ç›´è¡Œï¼ˆè‡ªå‹•è£œï¼‰
    cars.push({ kind:'M1R', route:'straight', x:g.W+80, y:g.lane.m1_west_y, vx:-sp, vy:0, w:CAR_W, h:CAR_H, turned:false });
  }

  // ===== æ’éšŠè·Ÿè»Š =====
  const SAFE_GAP = 10;

  function laneKey(car){
    if (car.kind === 'M1L') return 'M1L';
    if (car.kind === 'M1R') return 'M1R';
    if (car.kind === 'M2')  return `M2_${car.laneIdx}`;
    return null;
  }
  function sCoord(car){
    if (car.kind === 'M1L') return car.x;
    if (car.kind === 'M1R') return -car.x;
    if (car.kind === 'M2')  return -car.y;
    return 0;
  }
  function lenAlong(car){
    if (car.kind === 'M2') return car.h;
    return car.w;
  }

  function updateCars(dt, sig, g){
    const slowFactor = 1.0;

    for (const car of cars){
      car.__needStop =
        approachingStop(car, g) &&
        !pastStop(car, g) &&
        !allowedBySignal(car, sig, g);
    }

    const lanes = new Map();
    for (const car of cars){
      const key = laneKey(car);
      if (!key) continue;
      if ((car.kind === 'M1L' || car.kind === 'M1R') && Math.abs(car.vx) <= 0.0001) continue;
      if (car.kind === 'M2' && Math.abs(car.vy) <= 0.0001) continue;
      if (!lanes.has(key)) lanes.set(key, []);
      lanes.get(key).push(car);
    }

    for (const arr of lanes.values()){
      arr.sort((a,b) => sCoord(b) - sCoord(a));
      for (let i=1; i<arr.length; i++){
        const leader = arr[i-1];
        const follower = arr[i];
        const gap = (sCoord(leader) - lenAlong(leader)/2) - (sCoord(follower) + lenAlong(follower)/2);
        if (gap < SAFE_GAP) follower.__needStop = true;
      }
    }

    for (const car of cars){
      if (!car.__needStop){
        car.x += car.vx * dt * slowFactor;
        car.y += car.vy * dt * slowFactor;
      }

      if (!car.turned){
        // ä¸»ç·š1 å¾€ä¸‹è½‰
        if ((car.kind === 'M1L' || car.kind === 'M1R') && car.route === 'down'){
          const turnX = g.road.x;
          if ((car.kind==='M1L' && car.x >= turnX) || (car.kind==='M1R' && car.x <= turnX)){
            car.turned = true;
            const sp = Math.abs(car.vx);
            car.vx = 0; car.vy = sp;
            car.x = g.lane.stem_out_x[0];
            car.w = CAR_H; car.h = CAR_W;
          }
        }

        // ä¸»ç·š2 è½‰å…¥ä¸»ç·š1
        if (car.kind === 'M2'){
          if (car.y <= g.road.y + 10){
            car.turned = true;
            const sp = Math.abs(car.vy);
            car.vy = 0;
            car.w = CAR_W; car.h = CAR_H;

            if (car.route === 'toLeft'){
              car.kind = 'M1R';
              car.route = 'straight';
              car.vx = -sp;
              car.y = g.lane.m1_west_y;
            } else {
              car.kind = 'M1L';
              car.route = 'straight';
              car.vx = sp;
              car.y = g.lane.m1_east_y;
            }
          }
        }
      }
    }

    for (let i=cars.length-1; i>=0; i--){
      const c = cars[i];
      if (c.x < -320 || c.x > g.W+320 || c.y < -320 || c.y > g.H+320) cars.splice(i,1);
    }
  }

  // ===== é€²å…¥ç›¸ä½ =====
  function enterPhase(newPhase){
    phase = newPhase;
    phaseElapsed = 0;

    const d = getDur();

    if (phase === PH.PSEQ){
      pedSteps = buildPedSteps();
      pedIndex = 0;
      remaining = pedSteps[pedIndex]?.dur ?? 2;
      lastServedAt.PED = simSec;
      return;
    }

    if (phase === PH.M1_Y)  { remaining = d.M1Y; return; }
    if (phase === PH.M2L_Y) { remaining = d.M2Y; return; }
    if (phase === PH.M2R_Y) { remaining = d.M2Y; return; }
    if (phase === PH.AR)    { remaining = d.AR;  return; }

    if (phase === PH.M1S_G) remaining = d.M1SG;
    if (phase === PH.M1T_G) remaining = d.M1TG;
    if (phase === PH.M2L_G) remaining = d.M2G;
    if (phase === PH.M2R_G) remaining = d.M2G;

    const g = geom();
    const q = measureQueues(g);
    const dem = demandForGreen(phase, q);
    if (dem <= CTRL.SKIP_IF_Q_LE) remaining = 1;

    if (phase === PH.M1S_G) lastServedAt.M1S = simSec;
    if (phase === PH.M1T_G) lastServedAt.M1T = simSec;
    if (phase === PH.M2L_G) lastServedAt.M2L = simSec;
    if (phase === PH.M2R_G) lastServedAt.M2R = simSec;
  }

  function nextAfterGreen(ph){
    if (ph === PH.M1S_G || ph === PH.M1T_G) return PH.M1_Y;
    if (ph === PH.M2L_G) return PH.M2L_Y;
    if (ph === PH.M2R_G) return PH.M2R_Y;
    return PH.AR;
  }

  let pedDue = 0;

  function tick1s(){
    simSec += 1;
    phaseElapsed += 1;
    remaining -= 1;

    // ğŸ§© JSON åŠ‡æœ¬æ¯ç§’å¥—ç”¨ï¼ˆä¸å½±éŸ¿ä½ åŸæœ¬æ§åˆ¶ï¼‰
    scenarioTick();

    // ğŸ“ å›å µåµæ¸¬ï¼ˆæ¯ç§’ï¼‰ï¼‹ğŸ”Š æ–¹å‘èªéŸ³ï¼‹ğŸ“Š log
    const g_now = geom();
    const sp_now = spillbackStatus(g_now);
    if (sp_now && sp_now.worst){
      logEvent({ type:'SPILLBACK', dir: sp_now.worst.key, severityPx: sp_now.worst.severityPx, reason: sp_now.worst.reason });
      voiceMaybeTrigger(sp_now.worst);
    }

    if (remaining > 0) return;

    const g = geom();
    const q = measureQueues(g);

    // ç¶ ç‡ˆå»¶é•·ï¼ˆå«ç§‘æŠ€äº¤è­¦å‹•æ…‹ maxï¼‰
    if (phase === PH.M1S_G || phase === PH.M1T_G || phase === PH.M2L_G || phase === PH.M2R_G){
      const [minG, maxG] = minMaxForGreen(phase);
      const dem = demandForGreen(phase, q);

      if (phaseElapsed < minG){
        remaining = 1;
        return;
      }

      if (dem >= CTRL.EXTEND_IF_Q_GE && phaseElapsed < maxG){
        remaining = CTRL.EXTEND_STEP;
        return;
      }

      // æ•‘æ´ç›¸ä½çµæŸï¼šå›å¾© + å†·å»
      if (cop.active){
        const ended =
          (phase === PH.M1S_G && cop.targetKey === 'M1S') ||
          (phase === PH.M1T_G && cop.targetKey === 'M1T') ||
          (phase === PH.M2L_G && cop.targetKey === 'M2L') ||
          (phase === PH.M2R_G && cop.targetKey === 'M2R');
        if (ended){
          cop.active = false;
          cop.targetKey = null;
          cop.boostedMax = null;
          cop.reason = '';
          cop.cooldownUntil = simSec + CTRL.COP_COOLDOWN_SEC;
        }
      }

      enterPhase(nextAfterGreen(phase));
      return;
    }

    // è¡Œäººç›¸ä½
    if (phase === PH.PSEQ){
      pedIndex += 1;
      if (pedIndex < pedSteps.length){
        remaining = pedSteps[pedIndex].dur;
        return;
      }
      enterPhase(PH.AR);
      return;
    }

    // é»ƒç‡ˆ â†’ å…¨ç´…
    if (phase === PH.M1_Y || phase === PH.M2L_Y || phase === PH.M2R_Y){
      enterPhase(PH.AR);
      return;
    }

    // å…¨ç´…ï¼šæ±ºå®šä¸‹ä¸€å€‹ç›¸ä½
    if (phase === PH.AR){
      // è¡Œäººå›ºå®šè¼ªåˆ°
      if (CTRL.PED_ALWAYS){
        if (simSec >= pedDue){
          pedDue = simSec + 1;
          enterPhase(PH.PSEQ);
          return;
        }
      } else {
        const pressure = q.m1StraightQ + q.m1TurnQ + q.m2LQ + q.m2RQ;
        const allowSuppress = pressure >= CTRL.PED_SUPPRESS_IF_PRESSURE_GE;
        const maxDelayReached = (simSec - lastServedAt.PED) >= CTRL.PED_MAX_DELAY;
        if (!allowSuppress || maxDelayReached){
          enterPhase(PH.PSEQ);
          return;
        }
      }

      // ç§‘æŠ€äº¤è­¦æ’å…¥æ•‘æ´
      const decision = copDecide(g, q);
      if (decision && CTRL.COP_FORCE_INSERT){
        cop.active = true;
        cop.targetKey = decision.key;
        cop.reason = decision.reason;

        const baseMax =
          decision.key === 'M1S' ? CTRL.M1S_MAX :
          decision.key === 'M1T' ? CTRL.M1T_MAX :
          decision.key === 'M2L' ? CTRL.M2L_MAX :
          CTRL.M2R_MAX;

        cop.boostedMax = baseMax + CTRL.COP_MAX_GREEN_BOOST;

        enterPhase(greenFromKey(decision.key));
        return;
      }

      // ä¸€èˆ¬å£“åŠ›æŒ‘é¸
      const nextKey = pickNextGreen(q);
      enterPhase(greenFromKey(nextKey));
      return;
    }
  }

  // ===== ç•«è·¯å£ =====
  function roundRect(x,y,w,h,r){
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y, x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x, y+h, r);
    ctx.arcTo(x, y+h, x, y, r);
    ctx.arcTo(x, y, x+w, y, r);
    ctx.closePath();
  }
  function dashed(x1,y1,x2,y2){
    ctx.save();
    ctx.setLineDash([16,10]);
    ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
    ctx.restore();
  }
  function zebra(x,y,w,h,dir){
    ctx.save();
    ctx.globalAlpha = 0.9;
    ctx.fillStyle = 'rgba(255,255,255,0.75)';
    const stripe=6,gap=6;
    if (dir==='vertical'){
      for(let yy=y; yy<y+h; yy+=stripe+gap) ctx.fillRect(x,yy,w,stripe);
    } else {
      for(let xx=x; xx<x+w; xx+=stripe+gap) ctx.fillRect(xx,y,stripe,h);
    }
    ctx.restore();
  }

  function drawRoad(g){
    ctx.clearRect(0,0,g.W,g.H);

    ctx.fillStyle = 'rgba(255,255,255,0.03)';
    ctx.fillRect(0, g.road.y-g.road.h/2, g.W, g.road.h);
    ctx.fillRect(g.road.x-g.road.w/2, g.road.y, g.road.w, g.H-g.road.y);

    ctx.strokeStyle='rgba(255,255,255,0.16)'; ctx.lineWidth=2;
    dashed(0, g.road.y, g.W, g.road.y);

    ctx.strokeStyle='rgba(255,255,255,0.13)'; ctx.lineWidth=2;
    ctx.beginPath();
    ctx.moveTo(g.road.x, g.road.y);
    ctx.lineTo(g.road.x, g.H);
    ctx.stroke();

    for (const x of [g.lane.stem_out_x[1], g.lane.stem_in_x[0]]){
      ctx.beginPath();
      ctx.moveTo(x, g.road.y+8);
      ctx.lineTo(x, g.H);
      ctx.stroke();
    }

    ctx.strokeStyle='rgba(255,255,255,0.10)'; ctx.lineWidth=3;
    ctx.strokeRect(0, g.road.y-g.road.h/2, g.W, g.road.h);
    ctx.strokeRect(g.road.x-g.road.w/2, g.road.y, g.road.w, g.H-g.road.y);

    zebra(g.xwalk.left.x, g.xwalk.left.y, g.xwalk.left.w, g.xwalk.left.h, 'vertical');
    zebra(g.xwalk.right.x, g.xwalk.right.y, g.xwalk.right.w, g.xwalk.right.h, 'vertical');
    zebra(g.xwalk.bottom.x, g.xwalk.bottom.y, g.xwalk.bottom.w, g.xwalk.bottom.h, 'horizontal');

    ctx.strokeStyle='rgba(255,255,255,0.60)'; ctx.lineWidth=4;
    ctx.beginPath(); ctx.moveTo(g.stop.m1_left,  g.road.y+g.road.h/2-6); ctx.lineTo(g.stop.m1_left,  g.road.y+6); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(g.stop.m1_right, g.road.y-g.road.h/2+6); ctx.lineTo(g.stop.m1_right, g.road.y-6); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(g.road.x+6, g.stop.m2_in); ctx.lineTo(g.road.x+g.road.w/2-6, g.stop.m2_in); ctx.stroke();

    ctx.fillStyle = 'rgba(232,238,252,0.78)';
    ctx.font = '12px ui-monospace, Menlo, Consolas, monospace';
    ctx.fillText('ä¸»ç·š1ï¼ˆå·¦ä¾†ï¼‰ç›´è¡Œ', 14, g.road.y + 60);
    ctx.fillText('ä¸»ç·š1ï¼ˆå³ä¾†ï¼‰ç›´è¡Œ/å·¦è½‰å¾€ä¸‹ï¼ˆåŠé‡ç–Šï¼‰', g.W-420, g.road.y - 52);
    ctx.fillText('ä¸»ç·š2ï¼ˆä¸‹æ–¹ï¼‰å·¦è»Šé“å·¦è½‰ï½œå³è»Šé“å³è½‰', g.road.x - 170, g.H-18);
  }

  function lamp(onCol, on){ return on ? onCol : 'rgba(255,255,255,0.12)'; }

  function draw3Lamp(x,y,state){
    ctx.save(); ctx.translate(x,y);
    ctx.fillStyle='rgba(0,0,0,0.45)'; roundRect(-14,-26,28,52,8); ctx.fill();
    const lamps=[
      {cy:-14,on:state==='RED',col:'rgba(255,70,70,1)'},
      {cy:  0,on:state==='YELLOW',col:'rgba(255,210,60,1)'},
      {cy: 14,on:state==='GREEN',col:'rgba(60,255,140,1)'},
    ];
    for(const l of lamps){
      ctx.beginPath(); ctx.arc(0,l.cy,7,0,Math.PI*2);
      ctx.fillStyle=lamp(l.col,l.on); ctx.fill();
    }
    ctx.restore();
  }

  function drawArrowLamp(x,y,state,dir){
    ctx.save(); ctx.translate(x,y);
    ctx.beginPath(); ctx.arc(0,0,8,0,Math.PI*2);
    const col = state==='GREEN' ? 'rgba(60,255,140,1)' : (state==='YELLOW' ? 'rgba(255,210,60,1)' : 'rgba(255,255,255,0.12)');
    ctx.fillStyle=col; ctx.fill();
    if (state !== 'RED'){
      ctx.strokeStyle='rgba(0,0,0,0.55)';
      ctx.lineWidth=2;
      ctx.beginPath();
      if (dir==='L'){
        ctx.moveTo(3,-3); ctx.lineTo(-2,0); ctx.lineTo(3,3);
        ctx.moveTo(-2,0); ctx.lineTo(4,0);
      } else {
        ctx.moveTo(-3,-3); ctx.lineTo(2,0); ctx.lineTo(-3,3);
        ctx.moveTo(-4,0); ctx.lineTo(2,0);
      }
      ctx.stroke();
    }
    ctx.restore();
  }

  function drawPedHead(x,y,state){
    ctx.save(); ctx.translate(x,y);
    ctx.fillStyle='rgba(0,0,0,0.42)'; roundRect(-16,-14,32,28,10); ctx.fill();
    ctx.font='12px ui-monospace, Menlo, Consolas, monospace';
    ctx.textAlign='center'; ctx.textBaseline='middle';
    if (state==='WALK'){ ctx.fillStyle='rgba(60,255,140,0.95)'; ctx.fillText('WALK',0,0); }
    else if (state==='CLEAR'){ ctx.fillStyle='rgba(255,210,60,0.95)'; ctx.fillText('CLR',0,0); }
    else { ctx.fillStyle='rgba(255,70,70,0.95)'; ctx.fillText('STOP',0,0); }
    ctx.restore();
  }

  function drawCountdown(x,y,sec){
    ctx.save(); ctx.translate(x,y);
    ctx.fillStyle='rgba(0,0,0,0.35)'; roundRect(-36,-18,72,36,12); ctx.fill();
    ctx.fillStyle='rgba(232,238,252,0.95)';
    ctx.font='16px ui-monospace, Menlo, Consolas, monospace';
    ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText(String(sec).padStart(2,'0'), 0, 1);
    ctx.restore();
  }

  function drawSignals(sig, g){
    draw3Lamp(g.stop.m1_left-14,  g.road.y+g.road.h/2-30, sig.m1);
    draw3Lamp(g.stop.m1_right+14, g.road.y-g.road.h/2+30, sig.m1);

    drawArrowLamp(g.road.x+48, g.stop.m2_in+42, sig.m2L, 'L');
    drawArrowLamp(g.road.x+20, g.stop.m2_in+42, sig.m2R, 'R');

    drawCountdown(g.road.x - 34, g.road.y - 60, remaining);

    drawPedHead(g.xwalk.left.x - 10,  g.road.y - 70, sig.pedLeft);
    drawPedHead(g.xwalk.right.x + 52, g.road.y + 70, sig.pedRight);
    drawPedHead(g.road.x - 95, g.xwalk.bottom.y + 56, sig.pedBottom);
  }

  function drawCars(){
    for (const car of cars){
      ctx.save();
      ctx.translate(car.x, car.y);

      if (Math.abs(car.vx) > Math.abs(car.vy)){
        if (car.vx < 0) ctx.rotate(Math.PI);
      } else {
        if (car.vy < 0) ctx.rotate(-Math.PI/2);
        else if (car.vy > 0) ctx.rotate(Math.PI/2);
      }

      if (car.kind === 'M2') ctx.fillStyle = 'rgba(170,160,255,0.95)';
      else if (car.route === 'down') ctx.fillStyle = 'rgba(100,240,200,0.95)';
      else ctx.fillStyle = 'rgba(120,200,255,0.95)';

      ctx.fillRect(-car.w/2, -car.h/2, car.w, car.h);

      ctx.fillStyle='rgba(0,0,0,0.35)';
      ctx.fillRect(-car.w/2 + 4, -car.h/2 + 3, car.w*0.4, car.h-6);

      ctx.fillStyle='rgba(255,80,80,0.8)';
      ctx.fillRect(car.w/2 - 4, -car.h/2 + 3, 3, car.h-6);

      ctx.restore();
    }
  }

  function phaseLabel(sig){
    if (phase === PH.PSEQ) return [`è¡Œäººï¼š${sig.pedWhich} ${sig.pedMode}`, sig.pedMode==='WALK' ? 'green' : 'yellow'];
    if (phase === PH.M1S_G) return ['ä¸»ç·š1 ç›´è¡Œç¶ ','green'];
    if (phase === PH.M1T_G) return ['ä¸»ç·š1 åŠé‡ç–Šç¶ ï¼ˆå¾ŒåŠæ®µå¯é‡ç–Šä¸»2å³è½‰ï¼‰','green'];
    if (phase === PH.M2L_G) return ['ä¸»ç·š2 å·¦è½‰ç¶ ï¼ˆç•«é¢å·¦è»Šé“å·¦è½‰ï¼‰','green'];
    if (phase === PH.M2R_G) return ['ä¸»ç·š2 å³è½‰ç¶ ï¼ˆç•«é¢å³è»Šé“å³è½‰ï¼‰','green'];
    if (phase === PH.M1_Y)  return ['ä¸»ç·š1 é»ƒ','yellow'];
    if (phase === PH.M2L_Y) return ['ä¸»ç·š2 å·¦è½‰é»ƒ','yellow'];
    if (phase === PH.M2R_Y) return ['ä¸»ç·š2 å³è½‰é»ƒ','yellow'];
    return ['å…¨ç´…ï¼ˆARï¼‰','red'];
  }

  function updateUI(sig){
    const [txt, color] = phaseLabel(sig);
    ui.phaseText.textContent = 'Phaseï¼š' + txt;
    ui.phaseDot.className = 'dot ' + color;

    ui.sigM1.textContent = sig.m1;
    ui.sigM2L.textContent = sig.m2L;
    ui.sigM2R.textContent = sig.m2R;
    ui.sigPed.textContent = `L:${sig.pedLeft} R:${sig.pedRight} B:${sig.pedBottom} (${sig.pedWhich}-${sig.pedMode})`;
    ui.count.textContent = remaining;

    const g = geom();
    const q = measureQueues(g);
    ui.qText.textContent = `M1T:${q.m1TurnQ} M1S:${q.m1StraightQ} M2L:${q.m2LQ} M2R:${q.m2RQ} (M2:${q.m2Q})`;

    if (ui.copText){
      if (cop.active){
        ui.copText.textContent = `æ•‘æ´ä¸­ï¼š${cop.targetKey}ï½œmaxâ†’${cop.boostedMax}ï½œ${cop.reason}`;
      } else {
        const left = Math.max(0, cop.cooldownUntil - simSec);
        ui.copText.textContent = left > 0 ? `å†·å»ä¸­ï¼š${left}s` : 'å¾…å‘½';
      }
    }
  }

  // ===== Controls / Loop =====
  let running = true;
  let acc = 0;
  let last = performance.now();
  let spawnAcc = 0;

  function softApply(){
    if (phase === PH.PSEQ){
      pedSteps = buildPedSteps();
      pedIndex = Math.min(pedIndex, Math.max(0, pedSteps.length-1));
      remaining = Math.min(remaining, pedSteps[pedIndex]?.dur ?? remaining);
      return;
    }
    remaining = Math.max(1, remaining);
  }

  for (const el of [
    ui.tM1SG, ui.tM1TG, ui.tM1Y, ui.tM2G, ui.tM2Y, ui.tAR, ui.spawn,
    ui.pLeftOn, ui.pBottomOn,
    ui.pLeftWalk, ui.pLeftClr, ui.pRightWalk, ui.pRightClr, ui.pBottomWalk, ui.pBottomClr,
    ui.pct_M1R_L, ui.pct_M1L_S, ui.pct_M2_R, ui.pct_M2_L
  ]) el.addEventListener('change', () => { readFlowPcts(); softApply(); });

  for (const el of [ui.pct_M1R_L, ui.pct_M1L_S, ui.pct_M2_R, ui.pct_M2_L]){
    el.addEventListener('input', readFlowPcts);
  }

  ui.btnRightXwalkOn?.addEventListener('click', () => setRightXwalk(true));
  ui.btnRightXwalkOff?.addEventListener('click', () => setRightXwalk(false));
  ui.pRightOn?.addEventListener('change', () => setRightXwalk(ui.pRightOn.checked));

  ui.toggle.addEventListener('click', () => {
    running = !running;
    ui.toggle.textContent = running ? 'æš«åœ' : 'ç¹¼çºŒ';
  });

  // ğŸ”Š èªéŸ³æŒ‰éˆ•
  ui.voiceTest?.addEventListener('click', () => {
    const mode = ui.voicePreset?.value || 'GEN';
    const msg = VOICE_BY_DIR[mode] || VOICE_BY_DIR.GEN;
    speak(msg);
    startVisualAlert();
    logEvent({ type:'VOICE_TEST', dir: mode, severityPx: null, message: msg });
  });
  ui.voiceStop?.addEventListener('click', stopSpeak);

  // ğŸ§© åŠ‡æœ¬æŒ‰éˆ•
  ui.loadScenario?.addEventListener('click', () => loadScenarioFromText(ui.scenarioJson.value || ''));
  ui.clearScenario?.addEventListener('click', () => {
    scenario = null; scenarioIdx = 0;
    ui.scenarioHint.textContent = 'å°šæœªè¼‰å…¥';
  });

  // ğŸ“Š log æŒ‰éˆ•
  ui.logDump?.addEventListener('click', () => dumpTrafficLog());
  ui.logExport?.addEventListener('click', () => exportTrafficLog());

  ui.reset.addEventListener('click', () => {
    cars.length = 0;
    pedSteps = buildPedSteps(); pedIndex = 0;
    simSec = 0;
    voiceCooldownUntil = 0;
    alertUntil = 0;
    scenario = null; scenarioIdx = 0;
    TRAFFIC_LOG.length = 0;
    stopSpeak();
    for (const k of Object.keys(lastServedAt)) lastServedAt[k] = 0;
    cop = { active:false, targetKey:null, cooldownUntil:0, reason:'', boostedMax:null };
    enterPhase(PH.M1S_G);
    spawnAcc = 0;
  });

  function step(now){
    resizeCanvasToCSS();
    const g = geom();
    const dt = Math.min(0.05, (now-last)/1000);
    last = now;

    if (running){
      acc += dt;
      while (acc >= 1){ acc -= 1; tick1s(); }

      spawnAcc += dt;
      while (spawnAcc >= 1){
        spawnAcc -= 1;
        spawnCar(g);
      }
    }

    const sig = signals();
    if (running) updateCars(dt, sig, g);

    drawRoad(g);
    drawSignals(sig, g);
    drawCars();
    drawAlertOverlay(g);
    updateUI(sig);

    requestAnimationFrame(step);
  }

  // ===== start =====
  (function init(){
    // è¡Œäººç§’æ•¸å›ºå®šï¼ˆä½ åŸæœ¬çš„è¨­å®šï¼‰
    ui.pLeftOn.checked = true;  ui.pLeftWalk.value = 10; ui.pLeftClr.value = 6;
    ui.pBottomOn.checked = true;ui.pBottomWalk.value = 20;ui.pBottomClr.value = 8;
    ui.pRightWalk.value = 10;   ui.pRightClr.value = 6;

    setRightXwalk(true);
    pedSteps = buildPedSteps();

    readFlowPcts();
    enterPhase(PH.M1S_G);

    requestAnimationFrame(step);
    window.addEventListener('resize', () => resizeCanvasToCSS());
  })();
})();
</script>
</body>
</html>
